# 算法实现：(详细见代码文档) #

#给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。#

示例:

输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。

# 复盘 #

1. 暴力法会超时超内存,用循环判断1可能要比字符串的str.count方法要效率高一点,也许会降低内存
2. 采用递归方法,主要在于: 把数字1的数量分为以下三块的相加(设最高位为c):
	>最高位中1的出现数量
	>c00...之前最高位后面的位数中1的出现数量
	>c00...之后最高位后面的位数中1的出现数量

其中,最高位又分为两种情况:

1. 最高位c为1时,假设数字为1234,最终结果为以下三个结果的和:
	>最高位中1的出现数量为1000至1234的数量: **1234-1000+1=235**
	
	>1000之前后面三位数的1的出现数量: 0~999中1出现的数量,**递归传递参数为999**
	
	>1000之后后面三位数的1的出现数量:0~234中1出现的数量,**递归传递参数为234**

2. 最高位c不为1时,假设数字为3344,最终结果为以下三个结果的和:
	>最高位中1的出现数量为1000~1999: **也即为1000**

	>3000之前后面三位数的1的出现数量可分为0~999,1000~1999,2000~2999三个阶段,那么相当于0~999中1出现的数量乘以最高位的3,可得:**递归函数乘以3,且传递参数为999**

	>3000之后后面三位数的1的出现数量:0~344中1出现的数量,**递归传递参数为344**
# 算法实现：(详细见代码文档) #

给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 O(n)。

示例:

输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。

# 复盘 #

1. 用并查集的方法, 并查集的原理是, 将相关联的节点i连成树,节点i可作为列表的索引, 也可作为字典的key, 然后列表的值或者字典的value就可以作为节点i所属的子集
比如:

索引|0|1|2|3|4|5
--- |-- |-- |-- |-- |-- |-- |
值|0|0|0|0|0|0

则说明节点1-5都与节点0连接, 节点0为根节点

所以, 循环查找可以相连的节点, 将节点连起来, 同时对根节点下的节点进行计数(用count[根节点] 字典进行计数)

2.进一步,如果要合并两个树, 也就是合并两个子集, 那么, 就需要将矮的树合并到高的树, 这样能够减少递归找根节点的次数

参考资料: 
> https://segmentfault.com/a/1190000013805875